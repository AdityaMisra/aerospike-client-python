
			PyObject *key_op = NULL, *value = NULL;
			PyObject * py_index = NULL;
			PyObject * py_value = NULL;
			Py_ssize_t pos = 0;
			while (PyDict_Next(py_val, &pos, &key_op, &value)) {
				if (!PyString_Check(key_op)) {
					as_error_update(err, AEROSPIKE_ERR_CLIENT, "A operation key must be a string.");
					goto LOOP_CLEANUP;
				} else {
					char * name = PyString_AsString(key_op);
					if (!strcmp(name,"op") && (PyInt_Check(value) || PyLong_Check(value))) {
						operation = PyInt_AsLong(value);
					} else if (!strcmp(name, "bin")) {
						py_bin = value;
					} else if (!strcmp(name, "index")) {
						py_index = value;
					} else if (!strcmp(name, "val")) {
						py_value = value;
					} else {
						as_error_update(err, AEROSPIKE_ERR_PARAM, "operation can contain only op, bin, index and val keys");
						goto LOOP_CLEANUP;
					}
				}
			}

			if (py_bin) {
				if (PyUnicode_Check(py_bin)) {
					py_ustr = PyUnicode_AsUTF8String(py_bin);
					bin = PyBytes_AsString(py_ustr);
				} else if (PyString_Check(py_bin)) {
					bin = PyString_AsString(py_bin);
				} else if (PyByteArray_Check(py_bin)) {
					bin = PyByteArray_AsString(py_bin);
				} else {
					as_error_update(err, AEROSPIKE_ERR_PARAM, "Bin name should be of type string");
					goto LOOP_CLEANUP;
				}

				if (self->strict_types) {
					if (strlen(bin) > AS_BIN_NAME_MAX_LEN) {
						if (py_ustr) {
							Py_DECREF(py_ustr);
							py_ustr = NULL;
						}
						as_error_update(err, AEROSPIKE_ERR_BIN_NAME, "A bin name should not exceed 14 characters limit");
						goto LOOP_CLEANUP;
					}
				}
			} else if (!py_bin && operation != AS_OPERATOR_TOUCH) {
				as_error_update(err, AEROSPIKE_ERR_PARAM, "Bin is not given");
				goto LOOP_CLEANUP;
			}
			if (py_value) {
				if (self->strict_types) {
					if (check_type(self, py_value, operation, err)) {
						goto LOOP_CLEANUP;
					}
				}
			} else if ((!py_value) && (operation != AS_OPERATOR_READ && operation != AS_OPERATOR_TOUCH &&
						operation != OP_LIST_POP && operation != OP_LIST_REMOVE &&
						operation != OP_LIST_CLEAR && operation != OP_LIST_GET &&
						operation != OP_LIST_SIZE)) {
				as_error_update(err, AEROSPIKE_ERR_PARAM, "Value should be given");
				goto LOOP_CLEANUP;
			}

			if ((operation == OP_LIST_INSERT || operation == OP_LIST_INSERT_ITEMS ||
						operation == OP_LIST_POP || operation == OP_LIST_POP_RANGE ||
						operation == OP_LIST_REMOVE || operation == OP_LIST_REMOVE_RANGE ||
						operation == OP_LIST_SET || operation == OP_LIST_GET ||
						operation == OP_LIST_GET_RANGE || operation == OP_LIST_TRIM) && !py_index) {
				as_error_update(err, AEROSPIKE_ERR_PARAM, "Operation needs an index value");
				goto LOOP_CLEANUP;
			}

			if (self->strict_types) {
				if (py_index && !(operation == OP_LIST_INSERT || operation == OP_LIST_INSERT_ITEMS ||
						operation == OP_LIST_POP || operation == OP_LIST_POP_RANGE ||
						operation == OP_LIST_REMOVE || operation == OP_LIST_REMOVE_RANGE ||
						operation == OP_LIST_SET || operation == OP_LIST_GET ||
						operation == OP_LIST_GET_RANGE || operation == OP_LIST_TRIM)) {
					as_error_update(err, AEROSPIKE_ERR_PARAM, "Operation does not need an index value");
					goto LOOP_CLEANUP;
				}
			}

			if (py_index) {
				if (PyInt_Check(py_index)) {
					index = PyInt_AsLong(py_index);
				} else {
					as_error_update(err, AEROSPIKE_ERR_PARAM, "Index should be an integer");
					goto LOOP_CLEANUP;
				}
			}

			switch(operation) {
				case AS_OPERATOR_APPEND:
					if (PyUnicode_Check(py_value)) {
						py_ustr1 = PyUnicode_AsUTF8String(py_value);
						val = PyBytes_AsString(py_ustr1);
						as_operations_add_append_str(&ops, bin, val);
					} else if (PyString_Check(py_value)) {
						val = PyString_AsString(py_value);
						as_operations_add_append_str(&ops, bin, val);
					} else if (PyByteArray_Check(py_value)) {
						as_bytes *bytes;
						GET_BYTES_POOL(bytes, &static_pool, err);
						serialize_based_on_serializer_policy(self, SERIALIZER_PYTHON, &bytes, py_value, err);
						as_operations_add_append_rawp(&ops, bin, bytes->value, bytes->size, true);
					} else {
						if (!self->strict_types || !strcmp(py_value->ob_type->tp_name, "aerospike.null")) {
							as_operations *pointer_ops = &ops;
							as_binop *binop = &pointer_ops->binops.entries[pointer_ops->binops.size++];
							binop->op = AS_OPERATOR_APPEND;
							initialize_bin_for_strictypes(self, err, py_value, binop, bin, &static_pool);
						}
					}
					break;
				case AS_OPERATOR_PREPEND:
					if (PyUnicode_Check(py_value)) {
						py_ustr1 = PyUnicode_AsUTF8String(py_value);
						val = PyBytes_AsString(py_ustr1);
						as_operations_add_prepend_str(&ops, bin, val);
					} else if (PyString_Check(py_value)) {
						val = PyString_AsString(py_value);
						as_operations_add_prepend_str(&ops, bin, val);
					} else if (PyByteArray_Check(py_value)) {
						as_bytes *bytes;
						GET_BYTES_POOL(bytes, &static_pool, err);
						serialize_based_on_serializer_policy(self, SERIALIZER_PYTHON, &bytes, py_value, err);
						as_operations_add_prepend_rawp(&ops, bin, bytes->value, bytes->size, true);
					} else {
						if (!self->strict_types || !strcmp(py_value->ob_type->tp_name, "aerospike.null")) {
							as_operations *pointer_ops = &ops;
							as_binop *binop = &pointer_ops->binops.entries[pointer_ops->binops.size++];
							binop->op = AS_OPERATOR_PREPEND;
							initialize_bin_for_strictypes(self, err, py_value, binop, bin, &static_pool);
						}
					}
					break;
				case AS_OPERATOR_INCR:
					if (PyInt_Check(py_value)) {
						offset = PyInt_AsLong(py_value);
						as_operations_add_incr(&ops, bin, offset);
					} else if (PyLong_Check(py_value)) {
						offset = PyLong_AsLong(py_value);
						if (offset == -1 && PyErr_Occurred()) {
							if (PyErr_ExceptionMatches(PyExc_OverflowError)) {
								as_error_update(err, AEROSPIKE_ERR_PARAM, "integer value exceeds sys.maxsize");
								goto LOOP_CLEANUP;
							}
						}
						as_operations_add_incr(&ops, bin, offset);
					} else if (PyFloat_Check(py_value)) {
						double_offset = PyFloat_AsDouble(py_value);
						as_operations_add_incr_double(&ops, bin, double_offset);
					} else {
						if (!self->strict_types || !strcmp(py_value->ob_type->tp_name, "aerospike.null")) {
							as_operations *pointer_ops = &ops;
							as_binop *binop = &pointer_ops->binops.entries[pointer_ops->binops.size++];
							binop->op = AS_OPERATOR_INCR;
							initialize_bin_for_strictypes(self, err, py_value, binop, bin, &static_pool);
						}
					}
					break;
				case AS_OPERATOR_TOUCH:
					ops.ttl = 0;
					if (py_value && PyInt_Check(py_value)) {
						ops.ttl = PyInt_AsLong(py_value);
					} else if (py_value && PyLong_Check(py_value)) {
						ttl = PyLong_AsLong(py_value);
						if ((uint32_t)-1 == ttl) {
							as_error_update(err, AEROSPIKE_ERR_PARAM, "integer value for ttl exceeds sys.maxsize");
							goto LOOP_CLEANUP;
						}
						ops.ttl = ttl;
					}
					as_operations_add_touch(&ops);
					break;
				case AS_OPERATOR_READ:
					as_operations_add_read(&ops, bin);
					break;
				case AS_OPERATOR_WRITE:
					pyobject_to_astype_write(self, err, py_value, &put_val,
							&static_pool, SERIALIZER_PYTHON);
					if (err->code != AEROSPIKE_OK) {
						goto LOOP_CLEANUP;
					}
					as_operations_add_write(&ops, bin, (as_bin_value *) put_val);
					break;
				case OP_LIST_APPEND:
					pyobject_to_astype_write(self, err, py_value, &put_val,
						&static_pool, SERIALIZER_PYTHON);
					if (err->code != AEROSPIKE_OK) {
						goto LOOP_CLEANUP;
					}
					as_operations_add_list_append(&ops, bin, put_val);
					break;
				case OP_LIST_APPEND_ITEMS:
					pyobject_to_astype_write(self, err, py_value, &put_val,
						&static_pool, SERIALIZER_PYTHON);
					if (err->code != AEROSPIKE_OK) {
						goto LOOP_CLEANUP;
					}
					as_operations_add_list_append_items(&ops, bin, (as_list*)put_val);
					break;
				case OP_LIST_INSERT:
					pyobject_to_astype_write(self, err, py_value, &put_val,
						&static_pool, SERIALIZER_PYTHON);
					if (err->code != AEROSPIKE_OK) {
						goto LOOP_CLEANUP;
					}
					as_operations_add_list_insert(&ops, bin, index, put_val);
					break;
				case OP_LIST_INSERT_ITEMS:
					pyobject_to_astype_write(self, err, py_value, &put_val,
						&static_pool, SERIALIZER_PYTHON);
					if (err->code != AEROSPIKE_OK) {
						goto LOOP_CLEANUP;
					}
					as_operations_add_list_insert_items(&ops, bin, index, (as_list*)put_val);
					break;
				case OP_LIST_POP:
					as_operations_add_list_pop(&ops, bin, index);
					break;
				case OP_LIST_POP_RANGE:
					if (PyInt_Check(py_value)) {
						offset = PyInt_AsLong(py_value);
					} else if (PyLong_Check(py_value)) {
						offset = PyLong_AsLong(py_value);
						if (offset == -1 && PyErr_Occurred() && self->strict_types) {
							if (PyErr_ExceptionMatches(PyExc_OverflowError)) {
								as_error_update(err, AEROSPIKE_ERR_PARAM, "integer value exceeds sys.maxsize");
								goto LOOP_CLEANUP;
							}
						}
					} else {
						as_error_update(err, AEROSPIKE_ERR_PARAM, "Offset should be of int or long type");
						goto LOOP_CLEANUP;
					}
					as_operations_add_list_pop_range(&ops, bin, index, offset);
					break;
				case OP_LIST_REMOVE:
					as_operations_add_list_remove(&ops, bin, index);
					break;
				case OP_LIST_REMOVE_RANGE:
					if (PyInt_Check(py_value)) {
						offset = PyInt_AsLong(py_value);
					} else if (PyLong_Check(py_value)) {
						offset = PyLong_AsLong(py_value);
						if (offset == -1 && PyErr_Occurred() && self->strict_types) {
							if (PyErr_ExceptionMatches(PyExc_OverflowError)) {
								as_error_update(err, AEROSPIKE_ERR_PARAM, "integer value exceeds sys.maxsize");
								goto LOOP_CLEANUP;
							}
						}
					} else {
						as_error_update(err, AEROSPIKE_ERR_PARAM, "Offset should be of int or long type");
						goto LOOP_CLEANUP;
					}
					as_operations_add_list_remove_range(&ops, bin, index, offset);
					break;
				case OP_LIST_CLEAR:
					as_operations_add_list_clear(&ops, bin);
					break;
				case OP_LIST_SET:
					pyobject_to_astype_write(self, err, py_value, &put_val, &static_pool, SERIALIZER_PYTHON);
					if (err->code != AEROSPIKE_OK) {
						goto LOOP_CLEANUP;
					}
					as_operations_add_list_set(&ops, bin, index, put_val);
					break;
				case OP_LIST_GET:
					as_operations_add_list_get(&ops, bin, index);
					break;
				case OP_LIST_GET_RANGE:
					if (PyInt_Check(py_value)) {
						offset = PyInt_AsLong(py_value);
					} else if (PyLong_Check(py_value)) {
						offset = PyLong_AsLong(py_value);
						if (offset == -1 && PyErr_Occurred() && self->strict_types) {
							if (PyErr_ExceptionMatches(PyExc_OverflowError)) {
								as_error_update(err, AEROSPIKE_ERR_PARAM, "integer value exceeds sys.maxsize");
								goto LOOP_CLEANUP;
							}
						}
					} else {
						as_error_update(err, AEROSPIKE_ERR_PARAM, "Offset should be of int or long type");
						goto LOOP_CLEANUP;
					}
					as_operations_add_list_get_range(&ops, bin, index, offset);
					break;
				case OP_LIST_TRIM:
					if (PyInt_Check(py_value)) {
						offset = PyInt_AsLong(py_value);
					} else if (PyLong_Check(py_value)) {
						offset = PyLong_AsLong(py_value);
						if (offset == -1 && PyErr_Occurred() && self->strict_types) {
							if (PyErr_ExceptionMatches(PyExc_OverflowError)) {
								as_error_update(err, AEROSPIKE_ERR_PARAM, "integer value exceeds sys.maxsize");
								goto LOOP_CLEANUP;
							}
						}
					} else {
						as_error_update(err, AEROSPIKE_ERR_PARAM, "Offset should be of int or long type");
						goto LOOP_CLEANUP;
					}
					as_operations_add_list_trim(&ops, bin, index, offset);
					break;
				case OP_LIST_SIZE:
					as_operations_add_list_size(&ops, bin);
					break;
				default:
					if (self->strict_types) {
						as_error_update(err, AEROSPIKE_ERR_PARAM, "Invalid operation given");
						goto LOOP_CLEANUP;
					}
			}
		
