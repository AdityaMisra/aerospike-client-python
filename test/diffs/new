	PyObject *key_op = NULL, *value = NULL;
	PyObject * py_value = NULL;
	PyObject * py_key = NULL;
	PyObject * py_index = NULL;
	PyObject * py_map_policy = NULL;
	PyObject * py_return_type = NULL;
	Py_ssize_t pos = 0;
	while (PyDict_Next(py_val, &pos, &key_op, &value)) {
		if (!PyString_Check(key_op)) {
			return as_error_update(err, AEROSPIKE_ERR_CLIENT, "An operation key must be a string.");
		} else {
			char * name = PyString_AsString(key_op);
			if (!strcmp(name,"op") && (PyInt_Check(value) || PyLong_Check(value))) {
				operation = PyInt_AsLong(value);
			} else if (!strcmp(name, "bin")) {
				py_bin = value;
			} else if (!strcmp(name, "index")) {
				py_index = value;
			} else if (!strcmp(name, "val")) {
				py_value = value;
			} else if (!strcmp(name, "key")) {
				py_key = value;
			} else if (!strcmp(name, "map_policy")) {
				py_map_policy = value;
			} else if (!strcmp(name, "return_type")) {
				py_return_type = value;
			} else {
				return as_error_update(err, AEROSPIKE_ERR_PARAM,
						"Operation can contain only op, bin, index, key, val, return_type and map_policy keys");
			}
		}
	}

	if (py_bin) {
		if (PyUnicode_Check(py_bin)) {
			py_ustr = PyUnicode_AsUTF8String(py_bin);
			bin = strdup(PyBytes_AsString(py_ustr));
			as_vector_append(unicodeStrVector, &bin);
			Py_DECREF(py_ustr);
		} else if (PyString_Check(py_bin)) {
			bin = PyString_AsString(py_bin);
		} else if (PyByteArray_Check(py_bin)) {
			bin = PyByteArray_AsString(py_bin);
		} else {
			return as_error_update(err, AEROSPIKE_ERR_PARAM, "Bin name should be of type string");
		}

		if (self->strict_types) {
			if (strlen(bin) > AS_BIN_NAME_MAX_LEN) {
				return as_error_update(err, AEROSPIKE_ERR_BIN_NAME, "A bin name should not exceed 14 characters limit");
			}
		}
	} else if (operation != AS_OPERATOR_TOUCH) {
		return as_error_update(err, AEROSPIKE_ERR_PARAM, "Bin is not given");
	}

	if (py_value) {
		if (self->strict_types) {
			if (check_type(self, py_value, operation, err)) {
				return err->code;
			}
		}
		if (pyobject_to_astype_write(self, err, py_value, &put_val,
				static_pool, SERIALIZER_PYTHON) != AEROSPIKE_OK) {
			return err->code;
		}
	} else if (opRequiresValue(operation)) {
		return as_error_update(err, AEROSPIKE_ERR_PARAM, "Value should be given");
	}

	if (py_key) {
		if (pyobject_to_astype_write(self, err, py_key, &put_key,
				static_pool, SERIALIZER_PYTHON) != AEROSPIKE_OK) {
			return err->code;
		}
	}

	if (py_map_policy) {
		if (pyobject_to_map_policy(err, py_map_policy, &map_policy) != AEROSPIKE_OK) {
			return err->code;
		}
	}

	if (py_return_type) {
		if (!PyInt_Check(py_return_type)) {
			return as_error_update(err, AEROSPIKE_ERR_PARAM, "Return type should be an integer");
		}
		return_type = PyInt_AsLong(py_return_type);
	}

	if (!py_index && opRequiresIndex(operation)) {
		return as_error_update(err, AEROSPIKE_ERR_PARAM, "Operation needs an index value");
	}

	if (self->strict_types && py_index && !opRequiresIndex(operation)) {
		return as_error_update(err, AEROSPIKE_ERR_PARAM, "Operation does not need an index value");
	}

	if (py_index) {
		if (PyInt_Check(py_index)) {
			index = PyInt_AsLong(py_index);
		} else {
			return as_error_update(err, AEROSPIKE_ERR_PARAM, "Index should be an integer");
		}
	}

	switch(operation) {
		case AS_OPERATOR_APPEND:
			if (PyUnicode_Check(py_value)) {
				py_ustr1 = PyUnicode_AsUTF8String(py_value);
				val = strdup(PyBytes_AsString(py_ustr1));
				as_operations_add_append_str(ops, bin, val);
				as_vector_append(unicodeStrVector, &val);
				Py_DECREF(py_ustr1);
			} else if (PyString_Check(py_value)) {
				val = PyString_AsString(py_value);
				as_operations_add_append_str(ops, bin, val);
			} else if (PyByteArray_Check(py_value)) {
				as_bytes *bytes;
				GET_BYTES_POOL(bytes, static_pool, err);
				if (err->code == AEROSPIKE_OK) {
					serialize_based_on_serializer_policy(self, SERIALIZER_PYTHON, &bytes, py_value, err);
					as_operations_add_append_rawp(ops, bin, bytes->value, bytes->size, true);
				}
			} else {
				if (!self->strict_types || !strcmp(py_value->ob_type->tp_name, "aerospike.null")) {
					as_operations *pointer_ops = ops;
					as_binop *binop = &pointer_ops->binops.entries[pointer_ops->binops.size++];
					binop->op = AS_OPERATOR_APPEND;
					initialize_bin_for_strictypes(self, err, py_value, binop, bin, static_pool);
				}
			}
			break;
		case AS_OPERATOR_PREPEND:
			if (PyUnicode_Check(py_value)) {
				py_ustr1 = PyUnicode_AsUTF8String(py_value);
				val = strdup(PyBytes_AsString(py_ustr1));
				as_operations_add_prepend_str(ops, bin, val);
				as_vector_append(unicodeStrVector, &val);
				Py_DECREF(py_ustr1);
			} else if (PyString_Check(py_value)) {
				val = PyString_AsString(py_value);
				as_operations_add_prepend_str(ops, bin, val);
			} else if (PyByteArray_Check(py_value)) {
				as_bytes *bytes;
				GET_BYTES_POOL(bytes, static_pool, err);
				if (err->code == AEROSPIKE_OK) {
					serialize_based_on_serializer_policy(self, SERIALIZER_PYTHON, &bytes, py_value, err);
					as_operations_add_prepend_rawp(ops, bin, bytes->value, bytes->size, true);
				}
			} else {
				if (!self->strict_types || !strcmp(py_value->ob_type->tp_name, "aerospike.null")) {
					as_operations *pointer_ops = ops;
					as_binop *binop = &pointer_ops->binops.entries[pointer_ops->binops.size++];
					binop->op = AS_OPERATOR_PREPEND;
					initialize_bin_for_strictypes(self, err, py_value, binop, bin, static_pool);
				}
			}
			break;
		case AS_OPERATOR_INCR:
			if (PyInt_Check(py_value)) {
				offset = PyInt_AsLong(py_value);
				as_operations_add_incr(ops, bin, offset);
			} else if (PyLong_Check(py_value)) {
				offset = PyLong_AsLong(py_value);
				if (offset == -1 && PyErr_Occurred() && self->strict_types) {
					if (PyErr_ExceptionMatches(PyExc_OverflowError)) {
						return as_error_update(err, AEROSPIKE_ERR_PARAM, "integer value exceeds sys.maxsize");
					}
				}
				as_operations_add_incr(ops, bin, offset);
			} else if (PyFloat_Check(py_value)) {
				double_offset = PyFloat_AsDouble(py_value);
				as_operations_add_incr_double(ops, bin, double_offset);
			} else {
				if (!self->strict_types || !strcmp(py_value->ob_type->tp_name, "aerospike.null")) {
					as_operations *pointer_ops = ops;
					as_binop *binop = &pointer_ops->binops.entries[pointer_ops->binops.size++];
					binop->op = AS_OPERATOR_INCR;
					initialize_bin_for_strictypes(self, err, py_value, binop, bin, static_pool);
				}
			}
			break;
		case AS_OPERATOR_TOUCH:
			ops->ttl = 0;
			if (py_value && PyInt_Check(py_value)) {
				ops->ttl = PyInt_AsLong(py_value);
			} else if (py_value && PyLong_Check(py_value)) {
				ttl = PyLong_AsLong(py_value);
				if ((uint32_t)-1 == ttl && self->strict_types) {
					return as_error_update(err, AEROSPIKE_ERR_PARAM, "integer value for ttl exceeds sys.maxsize");
				}
				ops->ttl = ttl;
			}
			as_operations_add_touch(ops);
			break;
		case AS_OPERATOR_READ:
			as_operations_add_read(ops, bin);
			break;
		case AS_OPERATOR_WRITE:
			as_operations_add_write(ops, bin, (as_bin_value *) put_val);
			break;
		case OP_LIST_APPEND:
			as_operations_add_list_append(ops, bin, put_val);
			break;
		case OP_LIST_APPEND_ITEMS:
			as_operations_add_list_append_items(ops, bin, (as_list*)put_val);
			break;
		case OP_LIST_INSERT:
			as_operations_add_list_insert(ops, bin, index, put_val);
			break;
		case OP_LIST_INSERT_ITEMS:
			as_operations_add_list_insert_items(ops, bin, index, (as_list*)put_val);
			break;
		case OP_LIST_POP:
			as_operations_add_list_pop(ops, bin, index);
			break;
		case OP_LIST_POP_RANGE:
			if (PyInt_Check(py_value)) {
				offset = PyInt_AsLong(py_value);
			} else if (PyLong_Check(py_value)) {
				offset = PyLong_AsLong(py_value);
				if (offset == -1 && PyErr_Occurred() && self->strict_types) {
					if (PyErr_ExceptionMatches(PyExc_OverflowError)) {
						return as_error_update(err, AEROSPIKE_ERR_PARAM, "integer value exceeds sys.maxsize");
					}
				}
			} else {
				return as_error_update(err, AEROSPIKE_ERR_PARAM, "Offset should be of int or long type");
			}
			as_operations_add_list_pop_range(ops, bin, index, offset);
			break;
		case OP_LIST_REMOVE:
			as_operations_add_list_remove(ops, bin, index);
			break;
		case OP_LIST_REMOVE_RANGE:
			if (PyInt_Check(py_value)) {
				offset = PyInt_AsLong(py_value);
			} else if (PyLong_Check(py_value)) {
				offset = PyLong_AsLong(py_value);
				if (offset == -1 && PyErr_Occurred() && self->strict_types) {
					if (PyErr_ExceptionMatches(PyExc_OverflowError)) {
						return as_error_update(err, AEROSPIKE_ERR_PARAM, "integer value exceeds sys.maxsize");
					}
				}
			} else {
				return as_error_update(err, AEROSPIKE_ERR_PARAM, "Offset should be of int or long type");
			}
			as_operations_add_list_remove_range(ops, bin, index, offset);
			break;
		case OP_LIST_CLEAR:
			as_operations_add_list_clear(ops, bin);
			break;
		case OP_LIST_SET:
			as_operations_add_list_set(ops, bin, index, put_val);
			break;
		case OP_LIST_GET:
			as_operations_add_list_get(ops, bin, index);
			break;
		case OP_LIST_GET_RANGE:
			if (PyInt_Check(py_value)) {
				offset = PyInt_AsLong(py_value);
			} else if (PyLong_Check(py_value)) {
				offset = PyLong_AsLong(py_value);
				if (offset == -1 && PyErr_Occurred() && self->strict_types) {
					if (PyErr_ExceptionMatches(PyExc_OverflowError)) {
						return as_error_update(err, AEROSPIKE_ERR_PARAM, "integer value exceeds sys.maxsize");
					}
				}
			} else {
				return as_error_update(err, AEROSPIKE_ERR_PARAM, "Offset should be of int or long type");
			}
			as_operations_add_list_get_range(ops, bin, index, offset);
			break;
		case OP_LIST_TRIM:
			if (PyInt_Check(py_value)) {
				offset = PyInt_AsLong(py_value);
			} else if (PyLong_Check(py_value)) {
				offset = PyLong_AsLong(py_value);
				if (offset == -1 && PyErr_Occurred() && self->strict_types) {
					if (PyErr_ExceptionMatches(PyExc_OverflowError)) {
						return as_error_update(err, AEROSPIKE_ERR_PARAM, "integer value exceeds sys.maxsize");
					}
				}
			} else {
				return as_error_update(err, AEROSPIKE_ERR_PARAM, "Offset should be of int or long type");
			}
			as_operations_add_list_trim(ops, bin, index, offset);
			break;
		case OP_LIST_SIZE:
			as_operations_add_list_size(ops, bin);
			break;

